<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Runner Audio Extractor</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00ffcc;
            --secondary: #ff00ff;
            --bg: #050510;
            --panel: rgba(10, 20, 30, 0.8);
            --panel-border: #1a2a3a;
        }
        body { 
            margin: 0; 
            background: var(--bg); 
            font-family: 'Orbitron', sans-serif; 
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            width: 100%;
            max-width: 800px;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            color: var(--primary);
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 15px var(--primary);
            letter-spacing: 4px;
            font-size: 32px;
            position: relative;
        }
        
        .version {
            position: absolute;
            font-size: 10px;
            color: #555;
            bottom: -10px;
            right: 50%;
            transform: translateX(50%);
            letter-spacing: 2px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        .panel h2 {
            margin-top: 0;
            font-size: 14px;
            color: #667;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
            margin-bottom: 20px;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
        }

        .btn {
            background: rgba(0, 255, 204, 0.05);
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 12px 24px;
            font-family: inherit;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: 700;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
        }
        .btn-stop {
            border-color: #ff3366;
            color: #ff3366;
            background: rgba(255, 51, 102, 0.05);
        }
        .btn-stop:hover {
            background: #ff3366;
            color: #fff;
            box-shadow: 0 0 20px #ff3366;
        }
        .btn-copy {
            width: 100%;
            margin-top: 10px;
        }
        
        .btn-rand {
            padding: 5px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #444;
            background: #111;
            color: #888;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
        }
        .btn-rand:hover {
            border-color: var(--primary);
            color: var(--primary);
            box-shadow: 0 0 10px rgba(0,255,204,0.2);
        }

        .controls-row {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
            flex-wrap: wrap;
        }
        .controls-row label {
            width: 80px;
            font-size: 11px;
            color: #888;
            letter-spacing: 1px;
        }
        input[type=range] {
            flex: 1;
            accent-color: var(--primary);
            height: 4px;
            background: #333;
            appearance: none;
            border-radius: 2px;
            width: 100%;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary);
            cursor: pointer;
        }

        /* ADVANCED SETTINGS */
        .advanced-toggle {
            font-size: 10px;
            color: #556;
            text-decoration: underline;
            cursor: pointer;
            margin-left: auto;
        }
        .advanced-toggle:hover { color: var(--primary); }
        
        .advanced-panel {
            display: none;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-top: 1px solid #222;
            margin-top: 10px;
            width: 100%;
        }
        .advanced-panel.visible { display: block; }
        
        /* LAYERS GRID */
        .layer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .layer-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid #333;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
        }
        
        .layer-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid transparent;
        }

        .layer-card:hover {
            border-color: #555;
            background: rgba(255,255,255,0.05);
        }
        
        .layer-card.active {
            border-color: var(--primary);
            background: rgba(0, 255, 204, 0.05);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1) inset;
        }
        .layer-card.active .layer-header {
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
        }
        .layer-card.active .indicator {
            background: var(--primary);
            box-shadow: 0 0 8px var(--primary);
        }

        .layer-controls {
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .layer-top-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        select {
            background: #111;
            color: var(--primary);
            border: 1px solid #444;
            padding: 5px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            width: 100%;
            outline: none;
            flex: 1;
        }

        .vol-row {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 10px;
            color: #666;
        }

        .layer-name {
            font-size: 14px;
            font-weight: 700;
        }
        .layer-desc {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        .indicator {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            transition: all 0.2s;
        }

        #visualizer {
            height: 40px;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 0;
            color: #444;
            font-size: 14px;
            border: 1px solid #333;
            transition: all 0.1s;
            font-family: monospace;
        }
        #visualizer.active {
            color: var(--primary);
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
        }

        /* CODE EXPORT AREA */
        #code-export {
            width: 100%;
            height: 200px;
            background: #080810;
            border: 1px solid #333;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            box-sizing: border-box;
            resize: vertical;
            white-space: pre;
            overflow-x: auto;
        }
        #code-export::selection {
            background: var(--primary);
            color: #000;
        }

        .init-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(5, 5, 16, 0.95);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>

    <div id="init-overlay" class="init-overlay">
        <button class="btn" style="font-size: 24px; padding: 25px 50px; box-shadow: 0 0 50px var(--primary);" onclick="initAudio()">INITIALIZE AUDIO ENGINE</button>
    </div>

    <div class="container">
        <h1>NEON RUNNER <span style="font-size: 0.5em; color: #666; vertical-align: middle;">AUDIO LAB</span><span class="version">v1.0</span></h1>

        <!-- MUSIC PANEL -->
        <div class="panel">
            <h2>
                <span>SEQUENCER LOOP</span>
                <span id="bpm-display">300 BPM</span>
            </h2>
            
            <div class="controls-row">
                <button class="btn" onclick="audioSys.startMusic()">PLAY LOOP</button>
                <button class="btn btn-stop" onclick="audioSys.stopMusic()">STOP</button>
                <div id="visualizer" style="flex:1">IDLE</div>
            </div>

            <div class="controls-row">
                <label>MASTER VOL</label>
                <input type="range" min="0" max="100" value="40" oninput="updateVol(this.value)">
                <span class="advanced-toggle" onclick="toggleAdvanced()">[ ADVANCED SETTINGS ]</span>
            </div>

            <!-- ADVANCED SETTINGS PANEL -->
            <div id="advanced-panel" class="advanced-panel">
                <div class="controls-row">
                    <label>PACING</label>
                    <input id="input-bpm" type="range" min="60" max="450" value="300" oninput="updateBPM(this.value)">
                    <span id="pacing-val" style="width: 40px; font-size: 10px; text-align: right;">300</span>
                </div>
                <div class="controls-row">
                    <label>DENSITY</label>
                    <input id="input-density" type="range" min="0" max="100" value="100" oninput="updateDensity(this.value)">
                    <span id="density-val" style="width: 40px; font-size: 10px; text-align: right;">100%</span>
                </div>
                <div class="controls-row">
                    <label>CHAOS</label>
                    <input type="range" min="0" max="100" value="0" oninput="updateChaos(this.value)">
                    <span id="chaos-val" style="width: 40px; font-size: 10px; text-align: right;">0%</span>
                </div>
            </div>

            <div class="layer-grid">
                <!-- BASE -->
                <div class="layer-card active" id="card-base">
                    <div class="layer-header" onclick="toggleLayer('base')">
                        <div>
                            <div class="layer-name">CORE MELODY</div>
                            <div class="layer-desc">Main Lead</div>
                        </div>
                        <div class="indicator"></div>
                    </div>
                    <div class="layer-controls">
                        <div class="layer-top-row">
                            <select id="sel-base" onchange="updateVariation('base', this.value)">
                                <option value="saw">Sawtooth Lead</option>
                                <option value="square">Square Lead</option>
                                <option value="sine">Pure Sine</option>
                                <option value="detuned">Detuned Saw</option>
                                <option value="pluck">FM Pluck</option>
                                <option value="pad">Ghost Pad</option>
                            </select>
                            <button class="btn-rand" onclick="randomizeLayer('base')" title="Randomize Layer">ðŸŽ²</button>
                        </div>
                        <div class="vol-row">
                            <span>VOL</span>
                            <input id="vol-base" type="range" min="0" max="100" value="80" oninput="updateLayerVol('base', this.value)">
                        </div>
                    </div>
                </div>

                <!-- BASS -->
                <div class="layer-card" id="card-bass">
                    <div class="layer-header" onclick="toggleLayer('bass')">
                        <div>
                            <div class="layer-name">SYNTHWAVE BASS</div>
                            <div class="layer-desc">Driving Low End</div>
                        </div>
                        <div class="indicator"></div>
                    </div>
                    <div class="layer-controls">
                        <div class="layer-top-row">
                            <select id="sel-bass" onchange="updateVariation('bass', this.value)">
                                <option value="retro">Retro Saw (Outrun)</option>
                                <option value="sub">Deep Sub</option>
                                <option value="warm">Warm Moog</option>
                                <option value="analog">Analog Drift</option>
                                <option value="punch">Clean Punch</option>
                                <option value="dark">Dark Square</option>
                            </select>
                            <button class="btn-rand" onclick="randomizeLayer('bass')" title="Randomize Layer">ðŸŽ²</button>
                        </div>
                        <div class="vol-row">
                            <span>VOL</span>
                            <input id="vol-bass" type="range" min="0" max="100" value="80" oninput="updateLayerVol('bass', this.value)">
                        </div>
                    </div>
                </div>

                <!-- ARP -->
                <div class="layer-card" id="card-arp">
                    <div class="layer-header" onclick="toggleLayer('arp')">
                        <div>
                            <div class="layer-name">NEON ARPS</div>
                            <div class="layer-desc">High Pattern</div>
                        </div>
                        <div class="indicator"></div>
                    </div>
                    <div class="layer-controls">
                        <div class="layer-top-row">
                            <select id="sel-arp" onchange="updateVariation('arp', this.value)">
                                <option value="triangle">Triangle Pluck</option>
                                <option value="sine">Soft Sine</option>
                                <option value="square">Chip Square</option>
                                <option value="glass">Glass Bell</option>
                                <option value="bit">Bitcrush</option>
                                <option value="harp">Synth Harp</option>
                            </select>
                            <button class="btn-rand" onclick="randomizeLayer('arp')" title="Randomize Layer">ðŸŽ²</button>
                        </div>
                        <div class="vol-row">
                            <span>VOL</span>
                            <input id="vol-arp" type="range" min="0" max="100" value="80" oninput="updateLayerVol('arp', this.value)">
                        </div>
                    </div>
                </div>

                <!-- DRUMS -->
                <div class="layer-card" id="card-drums">
                    <div class="layer-header" onclick="toggleLayer('drums')">
                        <div>
                            <div class="layer-name">CYBER DRUMS</div>
                            <div class="layer-desc">Rhythm Section</div>
                        </div>
                        <div class="indicator"></div>
                    </div>
                    <div class="layer-controls">
                        <div class="layer-top-row">
                            <select id="sel-drums" onchange="updateVariation('drums', this.value)">
                                <option value="standard">Standard Kit</option>
                                <option value="heavy">Heavy Kick</option>
                                <option value="glitch">Glitch Perc</option>
                                <option value="lofi">Lo-Fi Kit</option>
                                <option value="vapor">Vaporwave</option>
                                <option value="trap">Trap Kit</option>
                            </select>
                            <button class="btn-rand" onclick="randomizeLayer('drums')" title="Randomize Layer">ðŸŽ²</button>
                        </div>
                        <div class="vol-row">
                            <span>VOL</span>
                            <input id="vol-drums" type="range" min="0" max="100" value="80" oninput="updateLayerVol('drums', this.value)">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- EXPORT PANEL -->
        <div class="panel">
            <h2>GENERATED SOURCE CODE</h2>
            <div style="font-size: 12px; color: #888; margin-bottom: 10px;">
                Copy this code to use the current audio configuration in your game.
            </div>
            <textarea id="code-export" readonly></textarea>
            <button class="btn btn-copy" onclick="copyCode()">COPY TO CLIPBOARD</button>
        </div>
    </div>

    <script>
        // --- EXTRACTED AUDIO CODE START ---
        const audioSys = {
            ctx: null, 
            masterGain: null, 
            isPlaying: false,
            step: 0,
            interval: null,
            
            // Configuration
            bpm: 300, 
            density: 1.0,
            chaos: 0.0,

            layers: { base: true, bass: false, arp: false, drums: false },
            
            // New Configs for customization
            layerConfig: {
                base: { vol: 0.8, variant: 'saw' },
                bass: { vol: 0.8, variant: 'retro' },
                arp:  { vol: 0.8, variant: 'triangle' },
                drums:{ vol: 0.8, variant: 'standard' }
            },

            // Tracks (Frequency Arrays)
            tracks: [
                [110, 110, 220, 165, 110, 220, 165, 130], // A2 Minorish
                [87, 87, 174, 130, 87, 130, 174, 196],    // F Majorish
                [130, 130, 196, 146, 130, 196, 261, 246]  // C Minorish
            ],
            currentTrackIdx: 0, 
            
            // Valid Options for Randomizer
            opts: {
                base: ['saw','square','sine','detuned','pluck','pad'],
                bass: ['retro','sub','warm','analog','punch','dark'],
                arp: ['triangle','sine','square','glass','bit','harp'],
                drums: ['standard','heavy','glitch','lofi','vapor','trap']
            },

            init() {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.connect(this.ctx.destination);
                    this.setVol(40);
                    return true;
                } catch(e) { 
                    console.error("Audio Init Failed", e); 
                    return false;
                }
            },

            setVol(v) { if (this.masterGain) this.masterGain.gain.value = v / 100; },

            startMusic() {
                if (!this.ctx) this.init();
                if (!this.ctx) return;
                try { if(this.ctx.state === 'suspended') this.ctx.resume(); } catch(e){}
                if (this.isPlaying) return; // Prevent double start
                
                this.step = 0;
                this.restartInterval();
                this.isPlaying = true;
                visualize(true);
            },

            restartInterval() {
                if (this.interval) clearInterval(this.interval);
                // 60000ms / BPM = duration of a beat. 
                const ms = 60000 / this.bpm;
                this.interval = setInterval(() => this.tick(), ms);
            },

            stopMusic() { 
                if (this.interval) clearInterval(this.interval); 
                this.isPlaying = false; 
                visualize(false);
            },

            randomizeState() {
                // Randomize layers
                ['base', 'bass', 'arp', 'drums'].forEach(k => {
                   this.layers[k] = Math.random() > 0.3; // 70% chance active
                   this.layerConfig[k].vol = 0.5 + Math.random() * 0.5; // 50-100% vol
                   const vars = this.opts[k];
                   this.layerConfig[k].variant = vars[Math.floor(Math.random() * vars.length)];
                });
                
                // Slight chaos to pacing and density
                const chaosFactor = this.chaos / 100;
                if(chaosFactor > 0) {
                     // Drift BPM +/- 10% * chaos
                     let drift = (Math.random() - 0.5) * 60 * chaosFactor;
                     this.bpm = Math.max(60, Math.min(450, this.bpm + drift));
                     
                     // Drift Density +/- 0.2 * chaos
                     let dDrift = (Math.random() - 0.5) * 0.4 * chaosFactor;
                     this.density = Math.max(0.2, Math.min(1.0, this.density + dDrift));
                }
                
                // Sync UI
                syncUI();
                if(this.isPlaying) this.restartInterval();
                generateCode();
            },

            tick() {
                // Chaos Logic
                if (this.chaos > 0 && this.step % 32 === 0 && this.step > 0) {
                     // Chance to randomize proportional to chaos (0-100)
                     if (Math.random() * 100 < this.chaos) {
                         this.randomizeState();
                     }
                }

                const t = this.ctx.currentTime;
                const track = this.tracks[this.currentTrackIdx];
                const noteIndex = this.step % track.length;
                
                // --- LAYER 1: BASE ---
                if (this.layers.base && Math.random() < this.density) {
                    const freq = track[noteIndex];
                    this.playBaseNote(t, freq, this.layerConfig.base.vol, this.layerConfig.base.variant);
                    if(typeof updateVisualizer === 'function') updateVisualizer(freq);
                }

                // --- LAYER 2: SYNTHWAVE BASS ---
                if (this.layers.bass && Math.random() < this.density) {
                    // Play on beats 0 and 4 
                    if (noteIndex % 4 === 0) {
                        const root = track[0] / 2; 
                        this.playBassNote(t, root, this.layerConfig.bass.vol, this.layerConfig.bass.variant);
                    }
                }

                // --- LAYER 3: ARP ---
                if (this.layers.arp && Math.random() < this.density) {
                    const baseFreq = track[noteIndex];
                    const multiplier = (this.step % 2 === 0) ? 1.5 : 2.0; 
                    this.playArpNote(t, baseFreq * multiplier, this.layerConfig.arp.vol, this.layerConfig.arp.variant);
                }

                // --- LAYER 4: DRUMS ---
                if (this.layers.drums && Math.random() < this.density) {
                    const v = this.layerConfig.drums.variant;
                    const vol = this.layerConfig.drums.vol;
                    if (noteIndex % 4 === 0) this.playKick(t, vol, v);
                    else if (noteIndex % 4 === 2) this.playSnare(t, vol, v);
                    this.playHiHat(t, vol, v);
                }

                this.step++;
                if (noteIndex === track.length - 1 && Math.random() < 0.2) {
                    this.currentTrackIdx = (this.currentTrackIdx + 1) % this.tracks.length;
                }
            },

            // --- SYNTHESIS METHODS ---

            playBaseNote(t, freq, vol, variant) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                // Defaults
                let type = 'sawtooth';
                let attack = 0;
                let decay = 0.2;
                
                if (variant === 'square') type = 'square';
                else if (variant === 'sine') type = 'sine';
                
                if (variant === 'detuned') {
                    // Two oscillators
                    const osc2 = this.ctx.createOscillator();
                    osc2.type = 'sawtooth';
                    osc2.frequency.setValueAtTime(freq * 1.01, t); // Detune
                    osc2.connect(filter);
                    osc2.start(t);
                    osc2.stop(t + 0.2);
                    type = 'sawtooth';
                }
                
                if (variant === 'pluck') {
                    decay = 0.1;
                } else if (variant === 'pad') {
                    attack = 0.1;
                    decay = 0.4;
                }

                osc.type = type;
                osc.frequency.setValueAtTime(freq, t);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, t);
                if (variant === 'pluck') {
                    filter.frequency.setValueAtTime(2000, t);
                    filter.frequency.exponentialRampToValueAtTime(100, t + decay);
                } else if (variant === 'pad') {
                    filter.frequency.setValueAtTime(200, t);
                    filter.frequency.linearRampToValueAtTime(1500, t + attack + 0.1);
                } else {
                    filter.frequency.linearRampToValueAtTime(2000, t + 0.1);
                }

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.15 * vol, t + (attack || 0.01));
                gain.gain.exponentialRampToValueAtTime(0.001, t + (attack || 0.01) + decay);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                osc.stop(t + (attack||0) + decay + 0.1);
            },

            playBassNote(t, freq, vol, variant) {
                const osc = this.ctx.createOscillator();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();
                let dur = 0.6;
                let type = 'sawtooth';

                // Default Env
                filter.type = 'lowpass';
                filter.Q.value = 1;
                gain.gain.setValueAtTime(0.3 * vol, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.5);

                if (variant === 'retro') {
                    // Classic Outrun
                    type = 'sawtooth';
                    filter.Q.value = 5;
                    filter.frequency.setValueAtTime(100, t);
                    filter.frequency.exponentialRampToValueAtTime(800, t + 0.3);
                } else if (variant === 'sub') {
                    // Deep Sub
                    type = 'triangle';
                    filter.frequency.value = 300;
                    gain.gain.setValueAtTime(0.5 * vol, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.6);
                } else if (variant === 'warm') {
                    // Warm Moog-ish
                    type = 'sawtooth';
                    filter.frequency.setValueAtTime(400, t);
                    filter.frequency.linearRampToValueAtTime(100, t+0.4);
                } else if (variant === 'analog') {
                    // Drifting
                    type = 'sawtooth';
                    osc.frequency.setValueAtTime(freq * 0.99, t);
                    osc.frequency.linearRampToValueAtTime(freq * 1.01, t+0.5);
                    filter.frequency.value = 500;
                } else if (variant === 'punch') {
                    // Clean Sine Punch
                    type = 'sine';
                    osc.frequency.setValueAtTime(freq*2, t);
                    osc.frequency.exponentialRampToValueAtTime(freq, t+0.1);
                    gain.gain.setValueAtTime(0.5*vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t+0.4);
                    filter.frequency.value = 1000;
                    dur = 0.4;
                } else if (variant === 'dark') {
                    // Dark Square
                    type = 'square';
                    filter.frequency.value = 250;
                    gain.gain.setValueAtTime(0.4*vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t+0.3);
                    dur = 0.3;
                }

                osc.type = type;
                if(variant !== 'analog' && variant !== 'punch') osc.frequency.setValueAtTime(freq, t);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + dur);
            },

            playArpNote(t, freq, vol, variant) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                let type = 'triangle';
                
                if (variant === 'sine') type = 'sine';
                else if (variant === 'square') type = 'square';
                
                if (variant === 'glass') {
                    const osc2 = this.ctx.createOscillator();
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(freq * 4.0, t); // 2 octaves up
                    const g2 = this.ctx.createGain();
                    g2.gain.value = 0.5;
                    osc2.connect(g2);
                    g2.connect(gain);
                    osc2.start(t); osc2.stop(t+0.1);
                    type = 'sine';
                } else if (variant === 'bit') {
                    type = 'sawtooth'; // Harsh
                    // Pseudo bitcrush via modulation or just high filter
                    const mod = this.ctx.createOscillator();
                    mod.type = 'square';
                    mod.frequency.value = freq * 0.5;
                    const mg = this.ctx.createGain();
                    mg.gain.value = 1000;
                    mod.connect(mg);
                    mg.connect(osc.frequency);
                    mod.start(t); mod.stop(t+0.1);
                } else if (variant === 'harp') {
                    type = 'triangle';
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.05 * vol, t + 0.02); // Pluck attack
                }

                osc.type = type;
                osc.frequency.setValueAtTime(freq, t);
                
                if (variant !== 'harp') gain.gain.setValueAtTime(0.05 * vol, t); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(t);
                osc.stop(t + 0.15);
            },

            playKick(t, vol, variant) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // standard, heavy, glitch, lofi, vapor, trap
                let startFreq = 150;
                let decay = 0.5;
                let type = 'sine';

                if (variant === 'heavy') { startFreq = 200; decay = 0.6; }
                if (variant === 'vapor') { startFreq = 100; decay = 0.4; } // Soft kick
                if (variant === 'trap') { startFreq = 150; decay = 1.0; } // Long 808
                if (variant === 'lofi') { startFreq = 120; decay = 0.3; }

                osc.type = type;
                osc.frequency.setValueAtTime(startFreq, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t + decay);
                
                gain.gain.setValueAtTime(0.5 * vol, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + decay);

                // Filter for lofi
                if (variant === 'lofi') {
                    const f = this.ctx.createBiquadFilter();
                    f.type = 'lowpass'; f.frequency.value = 200;
                    osc.connect(f); f.connect(gain);
                } else {
                    osc.connect(gain);
                }
                
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + decay);
            },

            playSnare(t, vol, variant) { 
                const bufferSize = this.ctx.sampleRate * 0.2; 
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                let freq = 1000;
                let dur = 0.1;

                if (variant === 'glitch') freq = 2000;
                if (variant === 'lofi') { filter.type = 'lowpass'; freq = 1500; }
                if (variant === 'vapor') { 
                    // Gated reverb style - burst of noise with abrupt cut
                    filter.type = 'lowpass'; freq = 8000; dur = 0.15; 
                }
                if (variant === 'trap') { freq = 2000; dur = 0.05; } // tight

                filter.frequency.value = freq;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.2 * vol, t);
                if(variant === 'vapor') {
                    // Gated gate
                    gain.gain.linearRampToValueAtTime(0.2 * vol, t+0.1);
                    gain.gain.linearRampToValueAtTime(0, t+0.11);
                } else {
                    gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
                }

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start(t);
            },

            playHiHat(t, vol, variant) { 
                const bufferSize = this.ctx.sampleRate * 0.05;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;
                
                if (variant === 'lofi') filter.frequency.value = 2000;
                if (variant === 'vapor') { filter.frequency.value = 8000; }

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.05 * vol, t); 
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start(t);
            }
        };
        // --- EXTRACTED AUDIO CODE END ---

        // UI HELPERS
        function initAudio() {
            if(audioSys.init()) {
                document.getElementById('init-overlay').style.display = 'none';
                generateCode();
            }
        }

        function toggleAdvanced() {
            document.getElementById('advanced-panel').classList.toggle('visible');
        }

        function updateVol(val) { audioSys.setVol(val); }
        function updateBPM(val) { 
            audioSys.bpm = parseFloat(val); 
            document.getElementById('pacing-val').innerText = val;
            if(audioSys.isPlaying) audioSys.restartInterval();
            generateCode();
        }
        function updateDensity(val) { 
            audioSys.density = val / 100;
            document.getElementById('density-val').innerText = val + "%";
            generateCode();
        }
        function updateChaos(val) {
            audioSys.chaos = val;
            document.getElementById('chaos-val').innerText = val + "%";
            generateCode();
        }

        function updateLayerVol(layerName, val) {
            audioSys.layerConfig[layerName].vol = val / 100;
            generateCode();
        }

        function updateVariation(layerName, val) {
            audioSys.layerConfig[layerName].variant = val;
            generateCode();
        }

        function toggleLayer(layerName) {
            audioSys.layers[layerName] = !audioSys.layers[layerName];
            syncUI();
            generateCode();
        }

        function randomizeLayer(layerName) {
            const vars = audioSys.opts[layerName];
            audioSys.layerConfig[layerName].variant = vars[Math.floor(Math.random() * vars.length)];
            audioSys.layerConfig[layerName].vol = 0.5 + Math.random() * 0.5;
            syncUI();
            generateCode();
        }

        function syncUI() {
            // Main Controls
            document.getElementById('pacing-val').innerText = Math.round(audioSys.bpm);
            document.getElementById('input-bpm').value = audioSys.bpm;
            
            document.getElementById('density-val').innerText = Math.round(audioSys.density*100) + "%";
            document.getElementById('input-density').value = audioSys.density * 100;

             Object.keys(audioSys.layers).forEach(k => {
                const card = document.getElementById('card-' + k);
                if (audioSys.layers[k]) card.classList.add('active');
                else card.classList.remove('active');
                
                document.getElementById('vol-'+k).value = audioSys.layerConfig[k].vol * 100;
                document.getElementById('sel-'+k).value = audioSys.layerConfig[k].variant;
             });
        }

        function updateVisualizer(freq) {
            const el = document.getElementById('visualizer');
            el.innerText = Math.round(freq) + " Hz";
            el.classList.remove('active');
            void el.offsetWidth; // trigger reflow
            el.classList.add('active');
        }

        function visualize(active) {
            const el = document.getElementById('visualizer');
            if(!active) {
                el.innerText = "OFFLINE";
                el.classList.remove('active');
            }
        }

        function generateCode() {
            // Simplified export that includes the improved synth algorithms
            const code = `
<!DOCTYPE html>
<html>
<head><title>Neon Audio v1.0</title></head>
<body>
<button onclick="audioSys.startMusic()">Start</button> <button onclick="audioSys.stopMusic()">Stop</button>
<script>
const audioSys = {
    ctx: null, masterGain: null, isPlaying: false, step: 0, interval: null,
    layers: ${JSON.stringify(audioSys.layers)},
    layerConfig: ${JSON.stringify(audioSys.layerConfig)},
    tracks: ${JSON.stringify(audioSys.tracks)},
    currentTrackIdx: 0, 
    bpm: ${audioSys.bpm}, density: ${audioSys.density}, chaos: ${audioSys.chaos},
    opts: ${JSON.stringify(audioSys.opts)},

    init() {
        try {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.masterGain.gain.value = 0.4;
        } catch(e) { console.error(e); }
    },

    startMusic() {
        if (!this.ctx) this.init();
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
        if (this.isPlaying) return;
        this.step = 0; this.restartInterval(); this.isPlaying = true;
    },
    stopMusic() { if(this.interval) clearInterval(this.interval); this.isPlaying = false; },
    restartInterval() { if(this.interval) clearInterval(this.interval); this.interval = setInterval(() => this.tick(), 60000 / this.bpm); },

    randomizeState() {
        ['base', 'bass', 'arp', 'drums'].forEach(k => {
            this.layers[k] = Math.random() > 0.3;
            this.layerConfig[k].vol = 0.5 + Math.random() * 0.5;
            const vars = this.opts[k];
            this.layerConfig[k].variant = vars[Math.floor(Math.random() * vars.length)];
        });
        const c = this.chaos / 100;
        if(c > 0) {
            this.bpm = Math.max(60, Math.min(450, this.bpm + (Math.random()-0.5)*60*c));
            this.density = Math.max(0.2, Math.min(1.0, this.density + (Math.random()-0.5)*0.4*c));
            if(this.isPlaying) this.restartInterval();
        }
    },

    tick() {
        if(!this.ctx) return;
        if (this.chaos > 0 && this.step % 32 === 0 && this.step > 0 && Math.random() * 100 < this.chaos) this.randomizeState();
        const t = this.ctx.currentTime;
        const track = this.tracks[this.currentTrackIdx];
        const noteIndex = this.step % track.length;
        
        if (this.layers.base && Math.random() < this.density) this.playBaseNote(t, track[noteIndex], this.layerConfig.base.vol, this.layerConfig.base.variant);
        if (this.layers.bass && Math.random() < this.density && noteIndex % 4 === 0) this.playBassNote(t, track[0]/2, this.layerConfig.bass.vol, this.layerConfig.bass.variant);
        if (this.layers.arp && Math.random() < this.density) this.playArpNote(t, track[noteIndex] * ((this.step%2===0)?1.5:2.0), this.layerConfig.arp.vol, this.layerConfig.arp.variant);
        if (this.layers.drums && Math.random() < this.density) {
            const v = this.layerConfig.drums.vol; const type = this.layerConfig.drums.variant;
            if (noteIndex % 4 === 0) this.playKick(t, v, type);
            else if (noteIndex % 4 === 2) this.playSnare(t, v, type);
            this.playHiHat(t, v, type);
        }
        this.step++;
        if (noteIndex === track.length - 1 && Math.random() < 0.2) this.currentTrackIdx = (this.currentTrackIdx + 1) % this.tracks.length;
    },

    playBaseNote(t, freq, vol, variant) {
        const osc=this.ctx.createOscillator(); const filter=this.ctx.createBiquadFilter(); const gain=this.ctx.createGain();
        let type='sawtooth', att=0, dec=0.2;
        if(variant==='square') type='square'; else if(variant==='sine') type='sine';
        else if(variant==='detuned') {
            const o2=this.ctx.createOscillator(); o2.type='sawtooth'; o2.frequency.setValueAtTime(freq*1.01, t);
            o2.connect(filter); o2.start(t); o2.stop(t+0.2);
        } else if(variant==='pluck') dec=0.1; else if(variant==='pad') { att=0.1; dec=0.4; }
        osc.type=type; osc.frequency.setValueAtTime(freq, t);
        filter.type='lowpass'; filter.frequency.setValueAtTime(800, t);
        if(variant==='pluck') { filter.frequency.setValueAtTime(2000,t); filter.frequency.exponentialRampToValueAtTime(100, t+dec); }
        else if(variant==='pad') { filter.frequency.setValueAtTime(200,t); filter.frequency.linearRampToValueAtTime(1500, t+att+0.1); }
        else filter.frequency.linearRampToValueAtTime(2000, t+0.1);
        gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.15*vol, t+(att||0.01));
        gain.gain.exponentialRampToValueAtTime(0.001, t+(att||0.01)+dec);
        osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
        osc.start(t); osc.stop(t+(att||0)+dec+0.1);
    },

    playBassNote(t, freq, vol, variant) {
        const osc=this.ctx.createOscillator(); const filter=this.ctx.createBiquadFilter(); const gain=this.ctx.createGain();
        let dur=0.6, type='sawtooth'; filter.type='lowpass'; filter.Q.value=1;
        gain.gain.setValueAtTime(0.3*vol, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
        if(variant==='retro') { type='sawtooth'; filter.Q.value=5; filter.frequency.setValueAtTime(100,t); filter.frequency.exponentialRampToValueAtTime(800, t+0.3); }
        else if(variant==='sub') { type='triangle'; filter.frequency.value=300; gain.gain.setValueAtTime(0.5*vol, t); gain.gain.linearRampToValueAtTime(0, t+0.6); }
        else if(variant==='warm') { type='sawtooth'; filter.frequency.setValueAtTime(400, t); filter.frequency.linearRampToValueAtTime(100, t+0.4); }
        else if(variant==='analog') { type='sawtooth'; osc.frequency.setValueAtTime(freq*0.99, t); osc.frequency.linearRampToValueAtTime(freq*1.01, t+0.5); filter.frequency.value=500; }
        else if(variant==='punch') { type='sine'; osc.frequency.setValueAtTime(freq*2, t); osc.frequency.exponentialRampToValueAtTime(freq, t+0.1); gain.gain.setValueAtTime(0.5*vol, t); gain.gain.exponentialRampToValueAtTime(0.001, t+0.4); filter.frequency.value=1000; dur=0.4; }
        else if(variant==='dark') { type='square'; filter.frequency.value=250; gain.gain.setValueAtTime(0.4*vol, t); gain.gain.exponentialRampToValueAtTime(0.001, t+0.3); dur=0.3; }
        osc.type=type; if(variant!=='analog' && variant!=='punch') osc.frequency.setValueAtTime(freq, t);
        osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain); osc.start(t); osc.stop(t+dur);
    },

    playArpNote(t, freq, vol, variant) {
        const osc=this.ctx.createOscillator(); const gain=this.ctx.createGain(); let type='triangle';
        if(variant==='sine') type='sine'; else if(variant==='square') type='square';
        if(variant==='glass') { const o2=this.ctx.createOscillator(); o2.type='sine'; o2.frequency.setValueAtTime(freq*4, t); const g2=this.ctx.createGain(); g2.gain.value=0.5; o2.connect(g2); g2.connect(gain); o2.start(t); o2.stop(t+0.1); type='sine'; }
        else if(variant==='bit') { type='sawtooth'; const m=this.ctx.createOscillator(); m.type='square'; m.frequency.value=freq*0.5; const mg=this.ctx.createGain(); mg.gain.value=1000; m.connect(mg); mg.connect(osc.frequency); m.start(t); m.stop(t+0.1); }
        else if(variant==='harp') { type='triangle'; gain.gain.setValueAtTime(0,t); gain.gain.linearRampToValueAtTime(0.05*vol, t+0.02); }
        osc.type=type; osc.frequency.setValueAtTime(freq, t);
        if(variant!=='harp') gain.gain.setValueAtTime(0.05*vol, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t+0.15);
        osc.connect(gain); gain.connect(this.masterGain); osc.start(t); osc.stop(t+0.15);
    },

    playKick(t, vol, variant) {
        const osc=this.ctx.createOscillator(); const gain=this.ctx.createGain();
        let s=150, d=0.5, type='sine';
        if(variant==='heavy') {s=200; d=0.6;} else if(variant==='vapor') {s=100; d=0.4;} else if(variant==='trap') {s=150; d=1.0;} else if(variant==='lofi') {s=120; d=0.3;}
        osc.type=type; osc.frequency.setValueAtTime(s, t); osc.frequency.exponentialRampToValueAtTime(0.01, t+d);
        gain.gain.setValueAtTime(0.5*vol, t); gain.gain.exponentialRampToValueAtTime(0.001, t+d);
        if(variant==='lofi') { const f=this.ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=200; osc.connect(f); f.connect(gain); }
        else osc.connect(gain);
        gain.connect(this.masterGain); osc.start(t); osc.stop(t+d);
    },

    playSnare(t, vol, variant) { 
        const b=this.ctx.createBuffer(1, this.ctx.sampleRate*0.2, this.ctx.sampleRate);
        const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const n=this.ctx.createBufferSource(); n.buffer=b;
        const f=this.ctx.createBiquadFilter(); f.type='highpass'; let freq=1000, dur=0.1;
        if(variant==='glitch') freq=2000; else if(variant==='lofi') {f.type='lowpass'; freq=1500;} else if(variant==='vapor') {f.type='lowpass'; freq=8000; dur=0.15;} else if(variant==='trap') {freq=2000; dur=0.05;}
        f.frequency.value=freq;
        const g=this.ctx.createGain(); g.gain.setValueAtTime(0.2*vol, t); 
        if(variant==='vapor') { g.gain.linearRampToValueAtTime(0.2*vol, t+0.1); g.gain.linearRampToValueAtTime(0, t+0.11); }
        else g.gain.exponentialRampToValueAtTime(0.001, t+dur);
        n.connect(f); f.connect(g); g.connect(this.masterGain); n.start(t);
    },

    playHiHat(t, vol, variant) { 
        const b=this.ctx.createBuffer(1, this.ctx.sampleRate*0.05, this.ctx.sampleRate);
        const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const n=this.ctx.createBufferSource(); n.buffer=b;
        const f=this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000;
        if(variant==='lofi') f.frequency.value=2000; else if(variant==='vapor') f.frequency.value=8000;
        const g=this.ctx.createGain(); g.gain.setValueAtTime(0.05*vol, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
        n.connect(f); f.connect(g); g.connect(this.masterGain); n.start(t);
    }
};
<\/script>
</body>
</html>`;
            document.getElementById('code-export').value = code.trim();
        }

        generateCode();
    </script>
</body>
</html>